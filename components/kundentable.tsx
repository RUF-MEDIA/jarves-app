'use client';

import { useState, useMemo, useEffect } from 'react';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import Link from 'next/link';
import { FiSettings, FiArrowUp, FiArrowDown, FiFilter } from 'react-icons/fi'; // Hinzugefügt FiFilter für das Filter-Icon
import { FaStar } from 'react-icons/fa';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import { Input } from '@/components/ui/input';
import { Select, SelectTrigger, SelectValue, SelectContent, SelectItem } from '@/components/ui/select';
import useSWR from 'swr';
import DatePicker from 'react-datepicker'; // Installieren Sie react-datepicker: npm install react-datepicker
import 'react-datepicker/dist/react-datepicker.css';

// Definiere die Spalten
const columns = [
  { key: 'autogeneratedNr', label: 'Kundennummer', filterable: false },
  { key: 'name', label: 'Kundenname', filterable: false },
  { key: 'status', label: 'Status', filterable: true },
  { key: 'kategorie', label: 'Kategorie', filterable: true },
  { key: 'strasse', label: 'Straße', filterable: false },
  { key: 'postleitzahl', label: 'Postleitzahl', filterable: false },
  { key: 'stadt', label: 'Stadt', filterable: false },
  { key: 'umsatzsteuerId', label: 'Umsatzsteuer-ID', filterable: false },
  { key: 'standort', label: 'Standort', filterable: false },
  { key: 'homepage', label: 'Homepage', filterable: false },
  { key: 'jobsite', label: 'Jobsite', filterable: false },
  { key: 'linkedin', label: 'LinkedIn', filterable: false },
  { key: 'xing', label: 'Xing', filterable: false },
  { key: 'zentraleMail', label: 'E-Mail', filterable: false },
  { key: 'zentralTelefon', label: 'Telefonnummer', filterable: false },
  { key: 'vermittlungsprovision', label: 'Vermittlungsprovision', filterable: false },
  { key: 'usbBeschreibung', label: 'USB Beschreibung', filterable: false },
  { key: 'interneNotizen', label: 'Interne Notizen', filterable: false },
  { key: 'erstelltAm', label: 'Erstellt Am', filterable: false },
  { key: 'letzteAenderungAm', label: 'Letzte Änderung Am', filterable: true },
  { key: 'betreuer', label: 'Betreuer', filterable: true },
];

// Definiere die Standard-Spalten
const defaultSelectedColumns = ['autogeneratedNr', 'name', 'status', 'kategorie', 'zentraleMail', 'zentralTelefon', 'betreuer'];

// Typen für die Daten
interface User {
  id: string;
  autogeneratedNr: number;
  name: string;
  status: string;
  kategorie: number | null;
  strasse: string;
  postleitzahl: string;
  stadt: string;
  umsatzsteuerId: string | null;
  standort: string;
  homepage?: string | null;
  jobsite?: string | null;
  linkedin?: string | null;
  xing?: string | null;
  zentraleMail?: string | null;
  zentralTelefon?: string | null;
  vermittlungsprovision?: string | null;
  usbBeschreibung?: string | null;
  interneNotizen?: string | null;
  erstelltAm: string;
  letzteAenderungAm: string;
  betreuer?: {
    id: string;
    name: string;
  } | null;
  unternehmensverknuepfung?: string | null;
  [key: string]: any;
}

interface Betreuer {
  id: string;
  name: string;
}

interface KundenTableProps {
  betreuerList: Betreuer[];
}

export function KundenTable({ betreuerList }: KundenTableProps) {
  const fetcher = (url: string) => fetch(url).then((res) => res.json());

  const { data: users, error, mutate } = useSWR<User[]>('/api/getUnternehmen', fetcher);

  const [selectedColumns, setSelectedColumns] = useState(defaultSelectedColumns);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [filterLetter, setFilterLetter] = useState('ALL');
  const [sortConfig, setSortConfig] = useState<{
    key: keyof User;
    direction: 'asc' | 'desc';
  } | null>(null);
  const [selectedRows, setSelectedRows] = useState<Set<string>>(new Set());
  const [newStatus, setNewStatus] = useState('');
  const [newBetreuer, setNewBetreuer] = useState('');
  const [newKategorie, setNewKategorie] = useState('');
  const [newVerknuepfung, setNewVerknuepfung] = useState('');

  // Filterzustände
  const [filters, setFilters] = useState<{
    [key: string]: any;
  }>({
    betreuer: 'all', // Standardmäßig auf 'all' setzen
    letzteAenderungAm: { start: null, end: null },
  });

  // Loggen der empfangenen Daten zur Überprüfung
  useEffect(() => {
    if (users) {
      console.log('Empfangene Benutzerdaten:', users);
    }
  }, [users]);

  // Ermitteln der verfügbaren Anfangsbuchstaben zur Filterung
  const availableLetters = useMemo(() => {
    if (!users) return [];
    const letters = new Set(users.map((user) => user.name.charAt(0).toUpperCase()));
    return Array.from(letters).sort();
  }, [users]);

  // Anwenden des Filters basierend auf dem ausgewählten Buchstaben und anderen Filtern
  const filteredUsers = useMemo(() => {
    if (!users) return [];

    return users.filter((user) => {
      // Filter nach Anfangsbuchstabe
      if (filterLetter !== 'ALL' && !user.name.startsWith(filterLetter)) {
        return false;
      }

      // Filter nach Betreuer
      if (filters.betreuer && filters.betreuer !== 'all' && user.betreuer?.id !== filters.betreuer) {
        return false;
      }

      // Filter nach Letzte Änderung am (Datum)
      if (filters.letzteAenderungAm.start || filters.letzteAenderungAm.end) {
        const letzteAenderung = new Date(user.letzteAenderungAm);
        if (filters.letzteAenderungAm.start && letzteAenderung < filters.letzteAenderungAm.start) {
          return false;
        }
        if (filters.letzteAenderungAm.end && letzteAenderung > filters.letzteAenderungAm.end) {
          return false;
        }
      }

      return true;
    });
  }, [users, filterLetter, filters]);

  // Anwenden der Sortierung
  const sortedUsers = useMemo(() => {
    if (!filteredUsers) return [];
    if (!sortConfig) return filteredUsers;

    const sorted = [...filteredUsers].sort((a, b) => {
      const aValue = a[sortConfig.key];
      const bValue = b[sortConfig.key];

      if (aValue < bValue) {
        return sortConfig.direction === 'asc' ? -1 : 1;
      }
      if (aValue > bValue) {
        return sortConfig.direction === 'asc' ? 1 : -1;
      }
      return 0;
    });

    return sorted;
  }, [filteredUsers, sortConfig]);

  const isSidebarOpen = selectedRows.size > 0;

  // Hier prüfen wir auf Fehler oder Ladezustand **nach** den Hooks
  if (error) return <div>Fehler beim Laden der Daten</div>;
  if (!users) return <div>Lade Daten...</div>;

  // Funktion zur Änderung der ausgewählten Spalten mit Sortierung
  const handleColumnChange = (key: string) => {
    setSelectedColumns((prev) => {
      if (prev.includes(key)) {
        // Entfernen der Spalte
        return prev.filter((col) => col !== key);
      } else {
        // Hinzufügen der Spalte und Sortieren basierend auf der columns-Reihenfolge
        const newSelected = [...prev, key];
        return columns.filter((col) => newSelected.includes(col.key)).map((col) => col.key);
      }
    });
  };

  // Funktion zur Handhabung der Sortierung
  const handleSort = (key: keyof User) => {
    let direction: 'asc' | 'desc' = 'asc';
    if (sortConfig && sortConfig.key === key && sortConfig.direction === 'asc') {
      direction = 'desc';
    }
    setSortConfig({ key, direction });
  };

  // Funktion zur Auswahl einzelner Zeilen
  const handleRowSelect = (id: string) => {
    setSelectedRows((prevSelected) => {
      const newSelected = new Set(prevSelected);
      if (newSelected.has(id)) {
        newSelected.delete(id);
      } else {
        newSelected.add(id);
      }
      return newSelected;
    });
  };

  // Funktion zur Auswahl oder Abwahl aller Zeilen
  const handleSelectAll = () => {
    if (selectedRows.size === users.length) {
      setSelectedRows(new Set());
    } else {
      setSelectedRows(new Set(users.map((user: User) => user.id)));
    }
  };

  // Funktion zur Massenaktion (Update oder Delete)
  const confirmBulkAction = async (action: 'update' | 'delete') => {
    try {
      const selectedIds = Array.from(selectedRows);

      if (action === 'delete') {
        // Senden der Löschanforderung an die API
        const response = await fetch('/api/bulkDeleteUnternehmen', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ids: selectedIds }),
        });

        if (response.ok) {
          console.log('Unternehmen erfolgreich gelöscht');
          // Daten erneut laden
          await mutate();
          setSelectedRows(new Set());
        } else {
          console.error('Fehler beim Löschen der Unternehmen');
        }
      } else {
        // Erstellen eines Objekts mit den Änderungen
        const updates: any = {};
        if (newStatus) updates.status = newStatus;
        if (newKategorie) updates.kategorie = parseInt(newKategorie, 10);
        if (newBetreuer) updates.betreuerId = newBetreuer;
        if (newVerknuepfung) updates.unternehmensverknuepfung = newVerknuepfung;

        // Senden der Aktualisierungsanforderung an die API
        const response = await fetch('/api/bulkUpdateUnternehmen', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ids: selectedIds, updates }),
        });

        if (response.ok) {
          console.log('Unternehmen erfolgreich aktualisiert');
          // Daten erneut laden
          await mutate();
          setSelectedRows(new Set());
          // Setze die Eingabefelder zurück
          setNewStatus('');
          setNewKategorie('');
          setNewBetreuer('');
          setNewVerknuepfung('');
        } else {
          console.error('Fehler beim Aktualisieren der Unternehmen');
        }
      }
    } catch (error) {
      console.error('Fehler bei der Massenaktion:', error);
    }
  };

  // Funktion zur dynamischen Darstellung der Tabellenzellen basierend auf dem Spaltenkey
  const renderCell = (unternehmen: User, key: string) => {
    let value = unternehmen[key];

    // Spezielle Behandlung für bestimmte Felder
    if (key === 'name') {
      return (
        <Link href={`/kunden/${unternehmen.id}`} className="text-blue-600 hover:underline">
          {value}
        </Link>
      );
    }

    if (key === 'kategorie') {
      return renderStars(value as number | null);
    }

    if (key === 'betreuer') {
      return unternehmen.betreuer ? unternehmen.betreuer.name : '-';
    }

    if (key === 'erstelltAm' || key === 'letzteAenderungAm') {
      return formatDate(value as string);
    }

    if (['homepage', 'jobsite', 'linkedin', 'xing'].includes(key)) {
      return value ? (
        <a href={value as string} target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline">
          {value}
        </a>
      ) : (
        '-'
      );
    }

    if (key === 'zentraleMail') {
      return value ? (
        <a href={`mailto:${value}`} className="text-blue-600 hover:underline">
          {value}
        </a>
      ) : (
        '-'
      );
    }

    if (key === 'zentralTelefon') {
      return value ? (
        <a href={`tel:${value}`} className="text-blue-600 hover:underline">
          {value}
        </a>
      ) : (
        '-'
      );
    }

    // Wenn der Wert null, undefined oder ein Objekt ist, das nicht gerendert werden kann
    if (value === null || value === undefined || (typeof value === 'object' && !React.isValidElement(value))) {
      return '-';
    }

    // Standardfall: Wert direkt zurückgeben
    return value.toString();
  };

  // Funktion zur Darstellung von Sternen basierend auf der Kategorie
  const renderStars = (rating: number | null) => {
    const validRating = rating || 0;
    return (
      <div className="flex space-x-1">
        {Array.from({ length: 5 }, (_, i) => (
          <FaStar key={i} className="w-4 h-4" color={i < validRating ? 'gold' : 'gray'} />
        ))}
      </div>
    );
  };

  // Funktion zur Formatierung von Datumsangaben
  const formatDate = (dateString: string | null) => {
    if (!dateString) return '';
    const date = new Date(dateString);
    return date.toLocaleDateString('de-DE');
  };

  // Funktionen zum Setzen der Filter
  const handleBetreuerFilterChange = (betreuerId: string) => {
    setFilters((prev) => ({
      ...prev,
      betreuer: betreuerId,
    }));
  };

  const handleDateFilterChange = (start: Date | null, end: Date | null) => {
    setFilters((prev) => ({
      ...prev,
      letzteAenderungAm: { start, end },
    }));
  };

  return (
    <div className="p-4 min-h-screen">
      {/* Filter Buttons */}
      <div className="mb-4 flex flex-wrap items-center space-x-2">
        <Button variant={filterLetter === 'ALL' ? 'default' : 'outline'} onClick={() => setFilterLetter('ALL')}>
          ALL
        </Button>
        {availableLetters.map((letter) => (
          <Button key={letter} variant={filterLetter === letter ? 'default' : 'outline'} onClick={() => setFilterLetter(letter)}>
            {letter}
          </Button>
        ))}
      </div>

      {/* Table */}
      <div className="overflow-x-auto bg-white rounded-lg shadow">
        <Table>
          <TableHeader>
            <TableRow className="bg-gray-200">
              {/* Checkbox für die Auswahl aller Zeilen */}
              <TableHead className="px-4 py-2">
                <Checkbox checked={selectedRows.size === users.length} onCheckedChange={handleSelectAll} />
              </TableHead>
              {/* Dynamische Darstellung der Spaltenüberschriften */}
              {columns
                .filter((col) => selectedColumns.includes(col.key))
                .map((col) => (
                  <TableHead key={col.key} className="px-4 py-2">
                    <div className="flex flex-col">
                      <div className="flex items-center space-x-1">
                        <span onClick={() => handleSort(col.key as keyof User)} className="cursor-pointer select-none">
                          {col.label}
                          {sortConfig?.key === col.key && <span>{sortConfig.direction === 'asc' ? <FiArrowUp /> : <FiArrowDown />}</span>}
                        </span>
                        {/* Filter-Icon anzeigen, wenn die Spalte filterbar ist */}
                        {col.filterable && (
                          <FiFilter
                            className="w-4 h-4 text-gray-600 cursor-pointer hover:text-gray-800"
                            onClick={() => {
                              // Toggle Filteranzeige (optional: Implementieren Sie eine Logik, um das Filter-Dropdown anzuzeigen)
                            }}
                          />
                        )}
                      </div>
                      {/* Filter Dropdown */}
                      {col.filterable && (
                        <div className="mt-2">
                          {col.key === 'betreuer' && (
                            <Select onValueChange={handleBetreuerFilterChange} value={filters.betreuer} placeholder="-- Betreuer filtern --">
                              <SelectTrigger className="w-full">
                                <SelectValue placeholder="-- Betreuer filtern --" />
                              </SelectTrigger>
                              <SelectContent>
                                <SelectItem value="all">Alle</SelectItem>
                                {betreuerList.map((betreuer) => (
                                  <SelectItem key={betreuer.id} value={betreuer.id}>
                                    {betreuer.name}
                                  </SelectItem>
                                ))}
                              </SelectContent>
                            </Select>
                          )}
                          {col.key === 'letzteAenderungAm' && (
                            <div className="flex space-x-2">
                              <DatePicker
                                selected={filters.letzteAenderungAm.start}
                                onChange={(date: Date | null) => handleDateFilterChange(date, filters.letzteAenderungAm.end)}
                                selectsStart
                                startDate={filters.letzteAenderungAm.start}
                                endDate={filters.letzteAenderungAm.end}
                                placeholderText="Startdatum"
                                className="border rounded p-1"
                              />
                              <DatePicker
                                selected={filters.letzteAenderungAm.end}
                                onChange={(date: Date | null) => handleDateFilterChange(filters.letzteAenderungAm.start, date)}
                                selectsEnd
                                startDate={filters.letzteAenderungAm.start}
                                endDate={filters.letzteAenderungAm.end}
                                minDate={filters.letzteAenderungAm.start}
                                placeholderText="Enddatum"
                                className="border rounded p-1"
                              />
                            </div>
                          )}
                        </div>
                      )}
                    </div>
                  </TableHead>
                ))}
              {/* Einstellungen-Icon für die Spaltenauswahl */}
              <TableHead className="px-4 py-2">
                <FiSettings onClick={() => setIsModalOpen(true)} className="w-5 h-5 text-gray-600 cursor-pointer hover:text-gray-800" />
              </TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {sortedUsers.map((unternehmen) => (
              <TableRow key={unternehmen.id} className="hover:bg-gray-50 transition-colors">
                {/* Checkbox für die Auswahl der Zeile */}
                <TableCell className="px-4 py-2">
                  <Checkbox checked={selectedRows.has(unternehmen.id)} onCheckedChange={() => handleRowSelect(unternehmen.id)} />
                </TableCell>
                {/* Dynamische Darstellung der Zellen basierend auf den ausgewählten Spalten */}
                {selectedColumns.map((colKey) => (
                  <TableCell key={colKey} className="px-4 py-2">
                    {renderCell(unternehmen, colKey)}
                  </TableCell>
                ))}
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>

      {/* Sidebar für Massenbearbeitung */}
      {isSidebarOpen && (
        <div className="fixed inset-y-0 right-0 w-full md:w-1/3 bg-white shadow-lg p-6 z-50 overflow-auto">
          <h2 className="text-2xl font-semibold mb-6">Massenbearbeitung ({selectedRows.size} ausgewählt)</h2>
          <div className="space-y-4">
            {/* Status ändern */}
            <div>
              <label htmlFor="status" className="block text-sm font-medium mb-1">
                Status ändern:
              </label>
              <Select onValueChange={(value) => setNewStatus(value)} value={newStatus}>
                <SelectTrigger className="w-full">
                  <SelectValue placeholder="-- Status auswählen --" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="inaktiv">Inaktiv</SelectItem>
                  <SelectItem value="Zielkunde">Zielkunde</SelectItem>
                  <SelectItem value="pending">Pending</SelectItem>
                  <SelectItem value="aktiv">Aktiv</SelectItem>
                  <SelectItem value="Rahmenvertragspartner">Rahmenvertragspartner</SelectItem>
                  <SelectItem value="nicht_kontaktieren">Nicht kontaktieren</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Kategorie ändern */}
            <div>
              <label htmlFor="kategorie" className="block text-sm font-medium mb-1">
                Kategorie ändern:
              </label>
              <Input
                type="number"
                id="kategorie"
                value={newKategorie}
                onChange={(e) => setNewKategorie(e.target.value)}
                min="1"
                max="5"
                placeholder="1 bis 5"
                className="w-full"
              />
            </div>

            {/* Betreuer zuweisen */}
            <div>
              <label htmlFor="betreuer" className="block text-sm font-medium mb-1">
                Betreuer zuweisen:
              </label>
              <Select onValueChange={(value) => setNewBetreuer(value)} value={newBetreuer}>
                <SelectTrigger className="w-full">
                  <SelectValue placeholder="-- Betreuer auswählen --" />
                </SelectTrigger>
                <SelectContent>
                  {betreuerList.map((betreuer) => (
                    <SelectItem key={betreuer.id} value={betreuer.id}>
                      {betreuer.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            {/* Unternehmensverknüpfung zuweisen */}
            <div>
              <label htmlFor="verknuepfung" className="block text-sm font-medium mb-1">
                Unternehmensverknüpfung zuweisen:
              </label>
              <Select onValueChange={(value) => setNewVerknuepfung(value)} value={newVerknuepfung}>
                <SelectTrigger className="w-full">
                  <SelectValue placeholder="-- Verknüpfung auswählen --" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Muttergesellschaft">Muttergesellschaft</SelectItem>
                  <SelectItem value="Tochtergesellschaft">Tochtergesellschaft</SelectItem>
                  <SelectItem value="Schwestergesellschaft">Schwestergesellschaft</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Info-Mail/Newsletter Button */}
            <div>
              <Button variant="secondary" className="w-full">
                Info-Mails/Newsletter senden
              </Button>
            </div>

            {/* Löschen Button */}
            <div>
              <Button variant="destructive" className="w-full" onClick={() => confirmBulkAction('delete')}>
                Ausgewählte löschen
              </Button>
            </div>

            {/* Bestätigen und Abbrechen Buttons */}
            <div className="flex justify-end space-x-2">
              <Button variant="default" onClick={() => confirmBulkAction('update')}>
                Änderungen speichern
              </Button>
              <Button variant="ghost" onClick={() => setSelectedRows(new Set())}>
                Abbrechen
              </Button>
            </div>
          </div>
        </div>
      )}

      {/* Modal für Spaltenauswahl */}
      <Dialog open={isModalOpen} onOpenChange={setIsModalOpen}>
        <DialogContent className="max-w-lg">
          <DialogHeader>
            <DialogTitle>Spalten anpassen</DialogTitle>
          </DialogHeader>
          <div className="space-y-4 mt-4">
            {columns.map((col) => (
              <div key={col.key} className="flex items-center">
                <Checkbox
                  checked={selectedColumns.includes(col.key)}
                  onCheckedChange={() => handleColumnChange(col.key)}
                  id={`col-${col.key}`}
                  className="mr-2"
                />
                <label htmlFor={`col-${col.key}`} className="text-sm">
                  {col.label}
                </label>
              </div>
            ))}
          </div>
          <DialogFooter className="mt-6">
            <Button onClick={() => setIsModalOpen(false)}>Schließen</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}
